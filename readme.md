## Вопрос №1

На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

Пример: 

def isEven(value):
      return value % 2 == 0


### Решение

Другим вариантом определения чётности числа является использование побитового оператора "И" (&).

В бинарном представление число заканчивается на 1, если оно не чётное, и на 0, если оно чётное.

**Пример:**

6 dec **->** 0000 011**0** bin

7 dec **->** 0000 011**1** bin


Отрицательные числа, представленны е в виде дополнительного кода (2's complement) внутри памяти процессора обладают такими же свойствамию

**Пример:**

-7 dec **->** 1111 100**1** bin

-6 dec **->** 1111 101**0** bin


Данное решение также эффективно будет работать и в других языках.


```python
def is_even_bitwise(value: int) -> bool:
    return value & 1 == 0
```

Код исходной функции и другого алгоритма представлен в модуле **task_1.main**

Тесты представлены в модуле tests.test_task_1.test_is_even

Бенчмарки представлены в модуле tests.test_task_1.benchmarks

**Бенчмарки:**

| Прогон | N итераций | is_even_classic | is_even_bitwise |
|---|---|---|---|
| 1 | 1_000_000_000 | 74.66 секунды | 72.94 секунды |
| 1 | 1_000_000_000 | 77.96 секунды | 71.81 секунды |
| 1 | 100_000_000 | 7.66 секунд | 6.7 секунд |
| 2 | 100_000_000 | 7.68 секунд | 6.7 секунд |
| 3 | 100_000_000 | 7.27 секунд | 6.55 секунд |

**Плюсы и минусы**

| Критерий | is_even_classic | is_even_bitwise |
| --- | --- | --- |
| Скорость выполнения | Медленнее | Быстрее |
| Понятность кода | Код понятен | Необходимо знать о том, как работает побитовый оператор &, чтобы понять код. Также реализация является нетипичной, поэтому код менее читаемый. Нарушение Дзен Python: Simple is better than complex |

## Вопрос №2

На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

Оценивается:

Полнота и качество реализации
Оформление кода
Наличие сравнения и пояснения по быстродействию


### Решение

Были написаны 2 класса - `ListCircularBuffer` и `ArrayCircularBuffer` в качестве реализации циклического FIFO буфера.

Решение находится в модуле task_2.

Тесты к решению лежат в tests.test_task_2

**Пояснение:**

Циклический буфер `ListCircularBuffer` основан на стандартном питоновском списке. В качестве маркера отсуствия значения используется тип `_EmptyValue` (см. [имплементацию](./task_2/list_circular_buffer.py)). 

Циклический буфер `ArrayCircularBuffer` основан на массиве `array` из модуля `array` (см. [документацию](https://docs.python.org/3/library/array.html)). Для отслеживания заполненных и пустых ячек используется ещё один массив `array`, в который вносятся значения `0` (ячейка пуста) и `1` (ячейка заполнена).

Оба буфера работают идентично со стороны клиента, кроме инициализации буфера на основе массива - помимо параметра `size` ArrayCircularBuffer требует параметр, аналогичный параметру `typecode` при создании массива `array.array`.

Общий интерфейс буферов:

- метод `push` - принимает значение и добавляет его в буфер
- метод `pop` - отдаёт заранее добавленное в буфер значение по принципу FIFO (first-in-first-out)

**Бенчмарки:**

Предположительно буфер на основе массива должен был работать быстрее, однако как показывают бэнчмарки, буфер на основе списка работает немного быстрее в большинстве случаев.

| Прогон | N итераций | ListCircularBuffer | ArrayCircularBuffer |
|---|---|---|---|
| 1 | 1_000_000 | 3.26 секунды | 3.72 секунды |
| 2 | 1_000_000 | 3.27 секунды | 3.36 секунды |
| 3 | 1_000_000 | 3.40 секунды | 3.31 секунды |


Однако, в случае сравнения по занимаемой памяти, буфер на основе массива выигрывает примено на **6.5%**. Модуль run_memory_profiler выводит значения использования памяти с помощью библиотеки guppy.

ListCircularBuffer: `Partition of a set of 53935 objects. Total size = 6279383 bytes.`
ArrayCircularBuffer: `Partition of a set of 43863 objects. Total size = 5932659 bytes.`


**Плюсы и минусы**

| Критерий | ListCircularBuffer | ArrayCircularBuffer |
| --- | --- | --- |
| Скорость выполнения | Немного быстрее в среднем | Немного медленнее в среднем |
| Занимаемая память | Занимает больше памяти | Занимает меньше памяти |
| Ограниченность типов данных | Можно добавлять любые типы данных в буфер | Можно использовать только типы данных, поддерживаемые `array.array` |

## Вопрос №3

На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.


### Решение

В Python используется алгоритм сортировки Timsort, который сочетает в себе преимущества сортировки вставками (Insertion sort) и сортировки слиянием (merge sort). Благодаря этой комбинации, в лучшем случае алгоритм отрабатывает за O(n), а в среднем и худшем случаях за O(n*log(n)). Алгоритм требует O(n) памяти.

Альтернативой данного алгоритма является алгоритм быстрой сортировки, который занимает по памяти O(log(n)). Однако в худшем случае быстра сортировка отрабатывает за O(n^2). В лучшем и среднем случаях быстрая сортировка работает за O(n*log(n)).

Сортировка вставками требует меньше всего памяти (O(1)), однако в среднем и худшем случаях имеет квадратичную сложность (O(n^2)).

Timsort лучше сортировки слиянием в лучшем случае. В среднем и худшем случаях Timsort не уступает сортировки слиянием. По памяти данные сортировки аналогичны.

**Итог: ** Необходимо использовать встроенные средства Python для сортировки, такие как метод `.sort()` и функция `sorted`. В Python во встроенных методах используется сортировка Timsort. Её прямым конкурентом является быстрая сортировка, использующаяся во многих языках программирования. Однако, в случае Python, как интерпретируемого языка, использующего для многих встроенных функций реализацию на языке C, вшитую в интерпретатор, не имеет особого смысла использовать самописные алгоритмы сортировки, так как в любом случае они будут работать гораздо медленнее встроенного решения (Timsort). Можно, однако, реализовать собственный алгоритм под конкретный случай (например, сортировку подсчётом, которая эффективна на ограниченной выборке значений) через модуль, написанный на языке C и [подключенный к программе](https://docs.python.org/3/extending/extending.html), но в текущем задании требуется выбрать сортировку для случайного массива, работающую в общем случае.
